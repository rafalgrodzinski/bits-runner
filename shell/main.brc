@import B
@import Syscall

CMD_REBOOT blob<@B.String>
CMD_TIME blob<@B.String>
CMD_M_INFO blob<@B.String>
CMD_F_INFO blob<@B.String>

@export start fun
    CMD_REBOOT <- @B.String("reboot")
    CMD_TIME <- @B.String("time")
    CMD_M_INFO <- @B.String("minfo")
    CMD_F_INFO <- @B.String("finfo")

    character u8 <- 0
    input blob<@B.String> <- @B.String("")
    cmd blob<@B.String> <- @B.String("")
    arg blob<@B.String> <- @B.String("")
    rep
        rep character != '\n'
            character <- @Syscall.readPressedAscii().u8
            if character = '\b': input.removeLast.val({input.adr})
            else if character != '\n' and character != '\0': input.append.val({input.adr}, character)

            if character != '\0'
                charString blob<@B.String> <- @B.StringForChar(character)
                charString.print.val({charString.adr})
            ;
        ;

        // split into cmd and arg
        loc u32 <- input.find.val({input.adr}, @B.String(" "))
        if loc > 0
            cmd <- input.subStringTo.val({input.adr}, loc)
            arg <- input.subStringFrom.val({input.adr}, loc + 1)
        else
            cmd <- input
        ;

        if cmd.isEqual.val({cmd.adr}, CMD_REBOOT)
            message blob<@B.String> <- @B.String("Rebooting...")
            message.println.val({message.adr})
            @Syscall.reboot()
        else if cmd.isEqual.val({cmd.adr}, CMD_TIME)
            timestamp u32 <- @Syscall.getTimestamp()
            message blob<@B.String> <- @B.StringForU32(timestamp)
            message.println.val({message.adr})
        else if cmd.isEqual.val({cmd.adr}, CMD_M_INFO)
            info blob<@Syscall.InfoMem> <- @Syscall.getInfoMem()
            text blob<@B.String>

            text <- @B.String("Total size: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.totalSize)
            text.println.val({text.adr})

            text <- @B.String("Total pages: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.totalPages)
            text.println.val({text.adr})

            text <- @B.String("Free pages: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.freePages)
            text.println.val({text.adr})

            text <- @B.String("Heap start: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.heapStart)
            text.println.val({text.adr})

            text <- @B.String("Heap size: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.heapSize)
            text.println.val({text.adr})

            text <- @B.String("Allocated bytes: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.allocateBytes)
            text.println.val({text.adr})
        else if cmd.isEqual.val({cmd.adr}, CMD_F_INFO)
            info blob<@Syscall.InfoFsEntry> <- @Syscall.getInfoFsEntry(arg)
            text blob<@B.String>

            text <- @B.String("Kind: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.kind)
            text.println.val({text.adr})

            text <- @B.String("Size: ")
            text.print.val({text.adr})
            text <- @B.StringForU32(info.entrySize)
            text.println.val({text.adr})
        else
            message blob<@B.String> <- @B.String("Unknown command")
            message.println.val({message.adr})
        ;

        character <- '\0'
        input.clear.val({input.adr})
    ;
;
