@module mem

@import term

@export heap u32 // marks start of the kernel heap

Layout blob
    memSize u32
    pageSize u32
    pagesCount u32
    memPages data<u8>
;
pMemLayout ptr<blob<Layout>>
freePagesCount u32 <- 0

HeapLayout blob
    pHeapStart ptr<u8>
    heapSize u32
    allocatedBytes u32
;
heapLayout blob<HeapLayout>

@export init fun
    pMemLayout <- { heap.adr }
    // Calculate free pages
    kernelPagesCount u32 <- 0
    rep i u32 <- 0, i < pMemLayout.val.pagesCount, i <- i + 1
        if pMemLayout.val.memPages[i] = 0.u8: freePagesCount <- freePagesCount + 1
        if pMemLayout.val.memPages[i] = 1.u8: kernelPagesCount <- kernelPagesCount + 1
    ;
    
    // Setup heap
    heapLayout.pHeapStart <- { heap.adr }
    heapLayout.heapSize <- kernelPagesCount * pMemLayout.val.pageSize - heap.adr & 0x0fff_ffff
    heapLayout.allocatedBytes <- blob<HeapLayout>.size + pMemLayout.val.pagesCount
;

@export allocatePageBytes fun: bytes u32 -> u32
    requestedPages u32 <- (bytes + pMemLayout.val.pageSize - 1) / pMemLayout.val.pageSize
    if freePagesCount < requestedPages: ret 0

    remainingPage u32 <- requestedPages
    rep i u32 <- 0, remainingPage > 0, i <- i + 1
        if pMemLayout.val.memPages[i] = 0.u8
            pMemLayout.val.memPages[i] <- 1.u8
            remainingPage <- remainingPage - 1
        ;
    ;

    freePagesCount <- freePagesCount - requestedPages
    ret requestedPages * pMemLayout.val.pageSize
;

@export allocateBytes fun: bytes u32 -> ptr<u8>
    ret allocateAlignedBytes(bytes, 0)
;

@export allocateAlignedBytes fun: bytes u32, alignment u32 -> ptr<u8>
    pBytes ptr<u8> <- { 0 }

    fillerSize u32 <- if alignment > 1: (alignment - ((heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes) % alignment)) % alignment else: 0

    if (heapLayout.heapSize - heapLayout.allocatedBytes) >= (bytes + fillerSize)
        pBytes <- { heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes + fillerSize }
        heapLayout.allocatedBytes <- heapLayout.allocatedBytes + bytes + fillerSize
    else
        requiredBytes u32 <- (bytes + fillerSize) - (heapLayout.heapSize - heapLayout.allocatedBytes)
        allocatedBytes u32 <- allocatePageBytes(requiredBytes)
        if allocatedBytes > 0
            heapLayout.heapSize <- heapLayout.heapSize + allocatedBytes
            pBytes <- { heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes + fillerSize }
            heapLayout.allocatedBytes <- heapLayout.allocatedBytes + bytes + fillerSize
        ;
    ;

    ret pBytes
;

@export virAdrToPhyAdr fun: address u32 -> u32
    pPageDirectory ptr<data<u32>> <- { 0xffc0_0000 }

    directoryIndex u32 <- (address & 0xffc0_0000) >> 22
    tableIndex u32 <- (address & 0x003f_f000) >> 12
    offset u32 <- address & 0x0000_0fff

    pageEntry u32 <- pPageDirectory.val[directoryIndex * 1024 + tableIndex]
    
    ret pageEntry & 0xffff_fc00 + offset
;

@export printMemStats fun
    @term.printString("Memory size: ", 7)
    @term.printHex(pMemLayout.val.memSize, 7)
    @term.printNewLine()

    @term.printString("Total pages: ", 7)
    @term.printHex(pMemLayout.val.pagesCount, 7)
    @term.printNewLine()

    @term.printString("Free pages: ", 7)
    @term.printHex(freePagesCount, 7)
    @term.printNewLine()

    @term.printString("Heap start: ", 7)
    @term.printHex(heapLayout.pHeapStart.vAdr, 7)
    @term.printNewLine()

    @term.printString("Heap size: ", 7)
    @term.printHex(heapLayout.heapSize, 7)
    @term.printNewLine()

    @term.printString("Allocated bytes: ", 7)
    @term.printHex(heapLayout.allocatedBytes, 7)
    @term.printNewLine()
;