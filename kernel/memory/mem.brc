@module mem

@import term

@export heap u32 // marks start of the kernel heap

Layout blob
    memSize u32
    pageSize u32
    pagesCount u32
    memPages data<u8>
;
pMemLayout ptr<blob<Layout>>
freePagesCount u32 <- 0

HeapLayout blob
    pHeapStart ptr<u8>
    heapSize u32
    allocatedBytes u32
;
heapLayout blob<HeapLayout>

getCr3 raw<"=r"> -> u32
    mov $0, cr3
;

setCr3 raw<"m">: address u32
    mov eax, $0
    mov cr3, eax
;

disableInterrupts raw<"">
    cli
;

enableInterrupts raw<"">
    sti
;

@export init fun
    pMemLayout <- { heap.adr }
    // Calculate free pages
    kernelPagesCount u32 <- 0
    rep i u32 <- 0, i < pMemLayout.val.pagesCount, i <- i + 1
        if pMemLayout.val.memPages[i] = 0.u8: freePagesCount <- freePagesCount + 1
        if pMemLayout.val.memPages[i] = 1.u8: kernelPagesCount <- kernelPagesCount + 1
    ;
    
    // Setup heap
    heapLayout.pHeapStart <- { heap.adr }
    heapLayout.heapSize <- kernelPagesCount * pMemLayout.val.pageSize - heap.adr & 0x0fff_ffff
    heapLayout.allocatedBytes <- blob<HeapLayout>.size + pMemLayout.val.pagesCount
;

@export allocatePageBytes fun: bytes u32 -> u32
    requestedPages u32 <- (bytes + pMemLayout.val.pageSize - 1) / pMemLayout.val.pageSize
    if freePagesCount < requestedPages: ret 0

    remainingPage u32 <- requestedPages
    rep i u32 <- 0, remainingPage > 0, i <- i + 1
        if pMemLayout.val.memPages[i] = 0.u8
            pMemLayout.val.memPages[i] <- 1.u8
            remainingPage <- remainingPage - 1
        ;
    ;

    freePagesCount <- freePagesCount - requestedPages
    ret requestedPages * pMemLayout.val.pageSize
;

@export allocateBytes fun: bytes u32 -> ptr<u8>
    ret allocateAlignedBytes(bytes, 0)
;

@export allocateAlignedBytes fun: bytes u32, alignment u32 -> ptr<u8>
    pBytes ptr<u8> <- { 0 }

    fillerSize u32 <- if alignment > 1: (alignment - ((heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes) % alignment)) % alignment else: 0

    if (heapLayout.heapSize - heapLayout.allocatedBytes) >= (bytes + fillerSize)
        pBytes <- { heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes + fillerSize }
        heapLayout.allocatedBytes <- heapLayout.allocatedBytes + bytes + fillerSize
    else
        requiredBytes u32 <- (bytes + fillerSize) - (heapLayout.heapSize - heapLayout.allocatedBytes)
        allocatedBytes u32 <- allocatePageBytes(requiredBytes)
        if allocatedBytes > 0
            heapLayout.heapSize <- heapLayout.heapSize + allocatedBytes
            pBytes <- { heapLayout.pHeapStart.vAdr + heapLayout.allocatedBytes + fillerSize }
            heapLayout.allocatedBytes <- heapLayout.allocatedBytes + bytes + fillerSize
        ;
    ;

    ret pBytes
;

@export allocateProcessPageBytes fun: pPageDirectory ptr<data<u32>>, size u32, lAdr u32 -> u32
    requestedPagesCount u32 <- (size + pMemLayout.val.pageSize - 1) / pMemLayout.val.pageSize
    if freePagesCount < requestedPagesCount: ret 0 

    disableInterrupts()
    oldCr3 u32 <- getCr3()
    setCr3(pPageDirectory.val[1023])
    remainingPagesCount u32 <- requestedPagesCount
    rep i u32 <- 0, remainingPagesCount > 0, i <- i + 1
        if pMemLayout.val.memPages[i] = 0.u8
            pageIndex u32 <- requestedPagesCount - remainingPagesCount
            registerPageForLAdr(pPageDirectory, i, lAdr + pageIndex * pMemLayout.val.pageSize)
            pMemLayout.val.memPages[i] <- 1.u8
            remainingPagesCount <- remainingPagesCount - 1
        ;
    ;
    setCr3(oldCr3)
    enableInterrupts()

    ret requestedPagesCount * pMemLayout.val.pageSize
;

registerPageForLAdr fun: pPageDirectory ptr<data<u32>>, page u32, lAdr u32
    directoryIndex u32 <- (lAdr & 0xffc0_0000) >> 22
    tableIndex u32 <- (lAdr & 0x003f_f000) >> 12

    // make sure page table exists
    if pPageDirectory.val[directoryIndex] & 0x01 = 0
        pPageTable ptr<data<u32>> <- allocateAlignedBytes(u32.size * 1024, 0x1000)
        rep i u32 <- 0, i < 1024, i <- i + 1: pPageTable.val[i] <- 0
        pPageDirectory.val[directoryIndex] <- lAdrToPAdr(pPageTable.vAdr) | 0x03
    ;

    // register page in page table
    pPageTables ptr<data<u32>> <- { 0xffc0_0000 }
    pPageTables.val[directoryIndex * 0x400 + tableIndex] <- (page * pMemLayout.val.pageSize) | 0x03
;

@export lAdrToPAdr fun: lAdr u32 -> u32
    pPageDirectory ptr<data<u32>> <- { 0xffc0_0000 }

    directoryIndex u32 <- (lAdr & 0xffc0_0000) >> 22
    tableIndex u32 <- (lAdr & 0x003f_f000) >> 12
    offset u32 <- lAdr & 0x0000_0fff

    pageEntry u32 <- pPageDirectory.val[directoryIndex * 1024 + tableIndex]
    
    ret pageEntry & 0xffff_fc00 + offset
;

@export printMemStats fun
    @term.printString("Memory size: ", 7)
    @term.printHex(pMemLayout.val.memSize, 7)
    @term.printNewLine()

    @term.printString("Total pages: ", 7)
    @term.printHex(pMemLayout.val.pagesCount, 7)
    @term.printNewLine()

    @term.printString("Free pages: ", 7)
    @term.printHex(freePagesCount, 7)
    @term.printNewLine()

    @term.printString("Heap start: ", 7)
    @term.printHex(heapLayout.pHeapStart.vAdr, 7)
    @term.printNewLine()

    @term.printString("Heap size: ", 7)
    @term.printHex(heapLayout.heapSize, 7)
    @term.printNewLine()

    @term.printString("Allocated bytes: ", 7)
    @term.printHex(heapLayout.allocatedBytes, 7)
    @term.printNewLine()
;