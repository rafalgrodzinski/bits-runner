@module Storage

@import mem

// Predefined
FAT_BYTES_PER_ENTRY u32 <- 0x20
FAT12_EOF u32 <- 0x0ff8
FAT16_EOF u32 <- 0xfff8

FS_KIND_FAT12 u32 <- 12
FS_KIND_FAT16 u32 <- 16

STORAGE_FS_ENTRY_KIND_FILE u32 <- 'f'
STORAGE_FS_ENTRY_KIND_DIR u32 <- 'd'

// FAT header offsets
FAT_BYTES_PER_SECTOR_OFFSET u32 <- 0x0b // 2 bytes
FAT_SECTORS_PER_CLUSTER_OFFSET u32 <- 0x0d // 1 byte
FAT_RESERVED_SECTORS_COUNT_OFFSET u32 <- 0x0e // 1 byte
FAT_FATS_COUNT_OFFSET u32 <- 0x10 // 1 byte
FAT_ROOT_DIR_ENTRIES_COUNT_OFFSET u32 <- 0x11 // 2 bytes
FAT_SECTORS_PER_FAT_OFFSET u32 <- 0x16 // 2 bytes
FAT_FS_ID_OFFSET u32 <- 0x36 // 8 bytes

// FAT Entry
FAT_ENTRY_ATTRIB_OFFSET u32 <- 0x0b // 1 byte
FAT_ENTRY_CLUSTER_OFFSET u32 <- 0x1a // 2 bytes
FAT_ENTRY_SIZE_OFFSET u32 <- 0x1c // 4 bytes

FAT_ATTRIB_HIDDEN u8 <- 0x02
FAT_ATTRIB_VOLUME_ID u8 <- 0x08
FAT_ATTRIB_LONG_FILE_NAME u8 <- 0x0f
FAT_ATTRIB_DIR u8 <- 0x10

FAT_FILE_FREE u8 <- 0xe5

StorageFsFat fun: storageArea blob<StorageArea> -> blob<StorageFs>
    storageFs blob<StorageFs>

    storageFs.storageArea <- storageArea
    storageFs.rootEntry <- {storageFsFatRootEntry.adr}
    storageFs.subEntriesForEntry <- {storageFsFatSubEntriesForEntry.adr}
    storageFs.readEntry <- {storageFsFatReadEntry.adr}

    // Init FAT
    pFatBuffer ptr<data<u8>> <- @mem.allocateBytes(512)
    storageArea.readSectors.val({storageArea.adr}, 0, 1, pFatBuffer)

    pInfo ptr<u32>

    // read values
    pInfo <- {pFatBuffer.vAdr + FAT_BYTES_PER_SECTOR_OFFSET}
    bytesPerSector u32 <- pInfo.val & 0xffff
    storageFs.fatBytesPerSector <- bytesPerSector

    pInfo <- {pFatBuffer.vAdr + FAT_SECTORS_PER_CLUSTER_OFFSET}
    sectorsPerCluster u32 <- pInfo.val & 0xff
    storageFs.fatSectorsPerCluster <- sectorsPerCluster

    pInfo <- {pFatBuffer.vAdr + FAT_RESERVED_SECTORS_COUNT_OFFSET}
    reservedSectorsCount u32 <- pInfo.val & 0xff

    pInfo <- {pFatBuffer.vAdr + FAT_FATS_COUNT_OFFSET}
    fatsCount u32 <- pInfo.val & 0xff

    pInfo <- {pFatBuffer.vAdr + FAT_ROOT_DIR_ENTRIES_COUNT_OFFSET}
    rootDirEntriesCount u32 <- pInfo.val & 0xffff
    storageFs.fatRootDirEntriesCount <- rootDirEntriesCount

    pInfo <- {pFatBuffer.vAdr + FAT_SECTORS_PER_FAT_OFFSET}
    sectorsPerFat u32 <- pInfo.val & 0xffff

    // calculated values
    fatFirstSector u32 <- reservedSectorsCount

    rootDirFirstSector u32 <- fatFirstSector + sectorsPerFat * fatsCount

    rootDirSectorsCount u32 <- (rootDirEntriesCount * FAT_BYTES_PER_ENTRY) / bytesPerSector

    storageFs.fatFirstDataSector <- rootDirFirstSector + rootDirSectorsCount

    // FAT type
    pInfo <- {pFatBuffer.vAdr + FAT_FS_ID_OFFSET + 4}
    if pInfo.val & 0xff = '2': storageFs.kind <- FS_KIND_FAT12
    else if pInfo.val & 0xff = '6': storageFs.kind <- FS_KIND_FAT16

    // load fat & root dir
    storageFs.pFat <- @mem.allocateBytes(sectorsPerFat * bytesPerSector)
    storageArea.readSectors.val({storageArea.adr}, fatFirstSector, sectorsPerFat, storageFs.pFat)

    storageFs.pFatRootDir <- @mem.allocateBytes(rootDirSectorsCount * bytesPerSector)
    storageArea.readSectors.val({storageArea.adr}, rootDirFirstSector, rootDirSectorsCount, storageFs.pFatRootDir)

    ret storageFs
;

storageFsFatRootEntry fun: it ptr<blob<StorageFs>> -> blob<StorageFsEntry>
    rootEntry blob<StorageFsEntry>
    rootEntry.kind <- STORAGE_FS_ENTRY_KIND_DIR
    rootEntry.name <- "\\"
    ret rootEntry
;

storageFsFatSubEntriesForEntry fun: it ptr<blob<StorageFs>>, parentEntry blob<StorageFs> -> data<blob<StorageFsEntry>, 32>
    subEntries data<blob<StorageFsEntry>, 32>

    entriesCount u32 <- 0
    pFatFileEntry ptr<data<u8>> <- it.val.pFatRootDir
    rep i u32 <- 0, i < it.val.fatRootDirEntriesCount and pFatFileEntry.val[0] != 0x00, i <- i + 1
        // first gather basic info about the entry
        attribute u8 <- pFatFileEntry.val[FAT_ENTRY_ATTRIB_OFFSET]
        isLongFileName bool <- attribute & FAT_ATTRIB_LONG_FILE_NAME = FAT_ATTRIB_LONG_FILE_NAME
        isVolumeId bool <- attribute & FAT_ATTRIB_VOLUME_ID = FAT_ATTRIB_VOLUME_ID and not isLongFileName
        isHidden bool <- attribute & FAT_ATTRIB_HIDDEN = FAT_ATTRIB_HIDDEN
        isDirectory bool <- attribute & FAT_ATTRIB_DIR = FAT_ATTRIB_DIR
        isNavigationDirectory bool <- (pFatFileEntry.val[0] = '.' and pFatFileEntry.val[1] = ' ') or (pFatFileEntry.val[0] = '.' and pFatFileEntry.val[1] = '.' and pFatFileEntry.val[2] = ' ') 
        isFile bool <- not isLongFileName and not isVolumeId and not isNavigationDirectory and not isDirectory and pFatFileEntry.val[0] != FAT_FILE_FREE

        name data<u8, 16>
        // copy name
        if isVolumeId or isDirectory or isFile
            targetIndex u32 <- 0
            sourceIndex u32 <- 0
            // file name
            rep sourceIndex < 8, sourceIndex <- sourceIndex + 1
                if pFatFileEntry.val[sourceIndex] != ' '
                    name[targetIndex] <- pFatFileEntry.val[sourceIndex]
                    targetIndex <- targetIndex + 1
                ;
            ;
            // dot
            if not isDirectory and not isVolumeId
                name[targetIndex] <- '.'
                targetIndex <- targetIndex + 1
            ;
            // extension
            rep sourceIndex < 11, sourceIndex <- sourceIndex + 1
                if pFatFileEntry.val[sourceIndex] != ' '
                    name[targetIndex] <- pFatFileEntry.val[sourceIndex]
                    targetIndex <- targetIndex + 1
                ;
            ;
            name[targetIndex] <- 0
        ;

        if isVolumeId
            it.val.name <- name
        else if isDirectory
            // kind
            subEntries[entriesCount].kind <- STORAGE_FS_ENTRY_KIND_DIR
            // name
            subEntries[entriesCount].name <- name
            // size
            pSize ptr<u32> <- {pFatFileEntry.vAdr + FAT_ENTRY_SIZE_OFFSET}
            subEntries[entriesCount].entrySize <- pSize.val
            // cluster
            pCluster ptr<u32> <- {pFatFileEntry.vAdr + FAT_ENTRY_CLUSTER_OFFSET}
            subEntries[entriesCount].fatCluster <- pCluster.val & 0xffff

            entriesCount <- entriesCount + 1
        else if isFile
            // kind
            subEntries[entriesCount].kind <- STORAGE_FS_ENTRY_KIND_FILE
            //name
            subEntries[entriesCount].name <- name
            // size
            pSize ptr<u32> <- {pFatFileEntry.vAdr + FAT_ENTRY_SIZE_OFFSET}
            subEntries[entriesCount].entrySize <- pSize.val
            // cluster
            pCluster ptr<u32> <- {pFatFileEntry.vAdr + FAT_ENTRY_CLUSTER_OFFSET}
            subEntries[entriesCount].fatCluster <- pCluster.val & 0xffff

            entriesCount <- entriesCount + 1
        ;

        // go to the next entry
        pFatFileEntry <- {pFatFileEntry.vAdr + FAT_BYTES_PER_ENTRY}
    ;

    ret subEntries
;

storageFsFatReadEntry fun: it ptr<blob<StorageFs>>, entry blob<StorageFsEntry>, targetAdr ptr<data<u8>> -> u32
    cluster u32 <- entry.fatCluster
    isFinished bool <- false

    rep not isFinished
        sector u32 <- (cluster - 2) * it.val.fatSectorsPerCluster + it.val.fatFirstDataSector
        it.val.storageArea.readSectors.val({it.val.storageArea.adr}, sector, it.val.fatSectorsPerCluster, targetAdr)
        targetAdr <- {targetAdr.vAdr + it.val.fatBytesPerSector * it.val.fatSectorsPerCluster}

        if it.val.kind = FS_KIND_FAT12
            // we multiply by 1.5 because FAT12 uses 1.5 bytes cluster entry
            clusterIndex u32 <- cluster * 3 / 2
            // calculate next cluster depending on wethere cluster index is odd or even
            pCluster ptr<u32> <- {it.val.pFat.vAdr + clusterIndex}

            if cluster & 0x01 = 0
                cluster <- pCluster.val & 0x0fff
            else
                cluster <- (pCluster.val & 0xfff0) >> 4
            ;

            isFinished <- cluster >= FAT12_EOF
        else if it.val.kind = FS_KIND_FAT16
            clusterIndex u32 <- cluster * 2
            pCluster ptr<u32> <- {it.val.pFat.vAdr + clusterIndex}
            cluster <- pCluster.val & 0xffff // just get 2 bytes

            isFinished <- cluster >= FAT16_EOF
        ;
    ;
    ret 0
;