@module scheduler

@import mem
@import term

Process blob
    pageDirectory data<u32, 1024>
    cr3 u32
    eip u32
    esp u32
    pid u32
;

getCr3 raw<"=r"> -> u32
    mov $0, cr3
;

setCr3 raw<"m">: address u32
    mov eax, $0
    mov cr3, eax
;

disableInterrupts raw<"">
    cli
;

enableInterrupts raw<"">
    sti
;

@export createProcess fun: imageSourceAddress ptr<data<u8>>, imageSize u32 -> ptr<blob<Process>>
    pProcess ptr<blob<Process>> <- @mem.allocateAlignedBytes(blob<Process>.size, 0x1000)
    pProcess.val.eip <- 0x40_00_00 // 4 MiB
    pProcess.val.esp <- 0x8000_0000 - 3 * u32.size // Just below the kernel with 3 slots for iret frame

    // Setup paging
    // clear all the data
    rep i u32 <- 0, i < 1024, i <- i + 1: pProcess.val.pageDirectory[i] <-  0

    pPageTable ptr<data<u32>>
    // identity paging of the first MiB
    pPageTable <- @mem.allocateAlignedBytes(u32.size * 1024, 0x1000)
    rep i u32 <- 0, i < 1024, i <- i + 1: pPageTable.val[i] <- 0
    rep i u32 <- 0, i < 256, i <- i + 1: pPageTable.val[i] <- (0x1000 * i) | 0b0000_0011 // RW & P
    pProcess.val.pageDirectory[0] <- @mem.lAdrToPAdr(pPageTable.vAdr) | 0b0000_0011 // RW & P

    // map kernel's memory 4 MiB
    pPageTable <- @mem.allocateAlignedBytes(u32.size * 1024, 0x1000)
    rep i u32 <- 0, i < 1024, i <- i + 1: pPageTable.val[i] <- ((0x1000 * i) + 0x10_00_00) | 0b0000_0011 // RW & P
    pProcess.val.pageDirectory[512] <- @mem.lAdrToPAdr(pPageTable.vAdr) | 0b0000_0011 // RW & P

    // store page directory address for process switching
    pProcess.val.cr3 <- @mem.lAdrToPAdr(pProcess.val.pageDirectory.adr)
    // map last memory page back to the page tables
    pProcess.val.pageDirectory[1023] <- pProcess.val.cr3 | 0x03

    // map process' memory
    allocatedSize u32 <- @mem.allocateProcessPageBytes({ pProcess.val.pageDirectory.adr }, imageSize, pProcess.val.eip)
    if allocatedSize = 0
        // TODO: Do some error handling or something
    ;

    // stack
    allocatedStackSize u32 <- @mem.allocateProcessPageBytes({ pProcess.val.pageDirectory.adr }, 0x01, pProcess.val.esp)
    if allocatedStackSize = 0
        // TODO: Do some error handling or something
    ;

    // Copy image to target address
    disableInterrupts()
    oldCr3 u32 <- getCr3()
    setCr3(pProcess.val.cr3)

    // setup iret frame
    pStack ptr<data<u32>> <- { pProcess.val.esp }
    pStack.val[2] <- 0x202 // eflags IF & 1
    pStack.val[1] <- 0x08 // cs
    pStack.val[0] <- pProcess.val.eip // eip

    imageTargetAddrss ptr<data<u8>> <- { pProcess.val.eip }
    rep i u32 <- 0, i < imageSize, i <- i + 1
        imageTargetAddrss.val[i] <- imageSourceAddress.val[i]
    ;

    setCr3(oldCr3)
    enableInterrupts()

    ret pProcess
;

switchToProcessRaw raw<"m,m">: esp u32, cr3 u32
    cli
    mov eax, $1
    mov cr3, eax
    mov esp, $0
    iretd
;

@export switchToProcess fun: pProcess ptr<blob<Process>>
    switchToProcessRaw(pProcess.val.esp, pProcess.val.cr3)
;