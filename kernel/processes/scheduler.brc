@module scheduler

@import mem

KERNEL_ADR u32 <- 0x8000_0000 // @ 3GiB
KERNEL_STACK_END_ADR u32 <- 0xc000_0000
KERNEL_STACK_SIZE u32 <- 256 * 1024 // 256KiB

USER_ADR u32 <- 0x40_0000 // @ 4 MiB
USER_STACK_END_ADR u32 <- 0x8000_0000 // just bellow kernel @ 3GiB
USER_STACK_SIZE u32 <- 256 * 1024 // 256KiB

GDT_DATA u32 <- 0x10
GDT_USER_CODE u32 <- 0x28 | 0x03
GDT_USER_DATA u32 <- 0x30 | 0x03
GDT_TSS u32 <- 0x38

Tss blob
    unused0 u32
    esp0 u32
    ss0 u32
    unused1 data<u32, 23>
;

@export Process blob
    pageDirectory data<u32, 1024>
    cr3 u32
    eip u32
    esp u32
    esp0 u32
    pid u32
;

getCr3 raw<"=r"> -> u32
    mov $0, cr3
;

setCr3 raw<"r">: adr u32
    mov cr3, $0
;

disableInterrupts raw<"">
    cli
;

enableInterrupts raw<"">
    sti
;

setTss raw<"m,~{eax}">: gdtEntry u32
    mov ax, $0
    ltr ax
;

tss blob<Tss>
pGdtTss ptr<data<u8>>

@export init fun: gdtTssAdr u32
    pGdtTss <- { gdtTssAdr }
    tss.ss0 <- GDT_DATA
;

@export createProcess fun: imageSourceAddress ptr<data<u8>>, imageSize u32 -> ptr<blob<Process>>
    pCurrentPageDirectory ptr<data<u32>> <- {getCr3()}

    pProcess ptr<blob<Process>> <- @mem.allocateAlignedBytes(blob<Process>.size, 0x1000)
    pProcess.val.eip <- USER_ADR
    pProcess.val.esp <- USER_STACK_END_ADR - 5 * u32.size // 5 slots for iret frame
    pProcess.val.esp0 <- KERNEL_STACK_END_ADR
    pProcess.val.cr3 <- @mem.lAdrToPAdr(pProcess.val.pageDirectory.adr.u32)
    pProcess.val.pageDirectory[1023] <- pProcess.val.cr3 | 0x13 // PCD & RW & P

    // Setup new page directory

    // copy first identity page directory
    pProcess.val.pageDirectory[0] <- pCurrentPageDirectory.val[0]

    // copy kernel page directories
    rep i u32 <- 512, i < 1023, i <- i + 1: pProcess.val.pageDirectory[i] <- pCurrentPageDirectory.val[i]

    // clear user page tables
    rep i u32 <- 1, i < 512, i <- i + 1: pProcess.val.pageDirectory[i] <-  0

    // user memory
    @mem.allocateProcessPageBytes(pCurrentPageDirectory, { pProcess.val.pageDirectory.adr }, imageSize, USER_ADR)

    // user stack memory
    @mem.allocateProcessPageBytes(pCurrentPageDirectory, { pProcess.val.pageDirectory.adr }, USER_STACK_SIZE, USER_STACK_END_ADR - USER_STACK_SIZE)

    pGdtTss.val[0] <- (blob<Tss>.size & 0x0000_00ff)
    pGdtTss.val[1] <- (blob<Tss>.size & 0x0000_ff00) >> 8
    pGdtTss.val[2] <- (tss.adr & 0x0000_00ff).u8
    pGdtTss.val[3] <- ((tss.adr & 0x0000_ff00) >> 8).u8
    pGdtTss.val[4] <- ((tss.adr & 0x00ff_0000) >> 16).u8
    pGdtTss.val[5] <- 0b1000_1001 // <7: present> <6-5: Priviledge Level> <4: 0 for TSS> <3: 32bit> <2-1: 0 for TSS> <0: 1 for TSS>
    pGdtTss.val[6] <- (blob<Tss>.size & 0x000f_0000) >> 16
    pGdtTss.val[7] <- ((tss.adr & 0xff00_0000) >> 24).u8

    // Copy user image to target address
    disableInterrupts()
    oldCr3 u32 <- getCr3()
    setCr3(pProcess.val.cr3)

    // setup iret frame
    pStack ptr<data<u32>> <- { pProcess.val.esp }
    pStack.val[4] <- GDT_USER_DATA // ss
    pStack.val[3] <- USER_STACK_END_ADR
    pStack.val[2] <- 0x0202 // eflags IF & 1
    pStack.val[1] <- GDT_USER_CODE // cs
    pStack.val[0] <- pProcess.val.eip // eip

    imageTargetAddrss ptr<data<u8>> <- { pProcess.val.eip }

    rep i u32 <- 0, i < imageSize, i <- i + 1
        imageTargetAddrss.val[i] <- imageSourceAddress.val[i]
    ;

    setCr3(oldCr3)
    enableInterrupts()

    ret pProcess
;

switchToProcessRaw raw<"m,m,m">: esp u32, cr3 u32, gdtUserData u32
    cli
    mov ax, $2
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    mov eax, $1
    mov cr3, eax
    mov esp, $0
    iretd
;

@export switchToProcess fun: pProcess ptr<blob<Process>>
    tss.esp0 <- pProcess.val.esp0
    setTss(GDT_TSS)
    switchToProcessRaw(pProcess.val.esp, pProcess.val.cr3, GDT_USER_DATA)
;