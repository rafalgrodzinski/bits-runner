@import term
@import mem
@import BiosService
@import scheduler
@import Storage

@extern interrupt_init_protected_mode fun

STACK_ADR u32 <- 0x2000 - 4

getEax raw<"=r"> -> u32
    mov $0, eax
;

getEbx raw<"=r"> -> u32
    mov $0, ebx
;

getEcx raw<"=r"> -> u32
    mov $0, ecx
;

getEdx raw<"=r"> -> u32
    mov $0, edx
;

call raw<"m">: entryAdr u32
    call $0
;

@export start fun
    // Get boot parameters from BIOS Service
    biosServiceAdr u32 <- getEax()
    gdtTssAdr u32 <- getEbx()
    bootPartitionFirstSector u32 <- getEcx()
    biosBootDriveNumber u32 <- getEdx()

    // Initialize subsystems
    @BiosService.init(biosServiceAdr)
    @scheduler.init(gdtTssAdr)
    @mem.init()
    @term.init(@term.MODE_80x25)
    interrupt_init_protected_mode()

    @term.printString("Initializing Bits Runner...\n", @term.FOREGROUND_GRAY)

    storageFs blob<@Storage.StorageFs> <- @Storage.bootStorageFs(biosBootDriveNumber, bootPartitionFirstSector)
    @term.printString("All ready, welcome to Bits Runner!\n", @term.FOREGROUND_GREEN)
    
    rootEntry blob<@Storage.StorageFsEntry> <- storageFs.rootEntry.val({storageFs.adr})
    subEntries data<blob<@Storage.StorageFsEntry> > <- storageFs.subEntriesForEntry.val({storageFs.adr}, rootEntry)

    /*rep i u32 <- 0, i < 16 and subEntries[i].name[0] != 0, i <- i + 1
        @term.printString(subEntries[i].name, @term.FOREGROUND_BROWN | @term.ATTRIB_LIGHT)
        @term.printNewLine()
    ;*/

    pApp ptr<data<u8>> <- @mem.allocateBytes(subEntries[4].entrySize)
    storageFs.readEntry.val({storageFs.adr}, subEntries[4], pApp)
    pProcess ptr<blob<@scheduler.Process> > <- @scheduler.createProcess(pApp, subEntries[4].entrySize)
    @scheduler.switchToProcess(pProcess)

    rep
    ;
;