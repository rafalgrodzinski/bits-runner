@module Storage

@import Mem

// Predefined
FAT_BYTES_PER_ENTRY u32 <- 0x20
FAT12_EOF u32 <- 0x0ff8
FAT16_EOF u32 <- 0xfff8

FS_KIND_FAT12 u32 <- 12
FS_KIND_FAT16 u32 <- 16

STORAGE_FS_ENTRY_KIND_FILE u32 <- 'f'
STORAGE_FS_ENTRY_KIND_DIR u32 <- 'd'

// FAT header offsets
FAT_BYTES_PER_SECTOR_OFFSET u32 <- 0x0b // 2 bytes
FAT_SECTORS_PER_CLUSTER_OFFSET u32 <- 0x0d // 1 byte
FAT_RESERVED_SECTORS_COUNT_OFFSET u32 <- 0x0e // 1 byte
FAT_FATS_COUNT_OFFSET u32 <- 0x10 // 1 byte
FAT_ROOT_DIR_ENTRIES_COUNT_OFFSET u32 <- 0x11 // 2 bytes
FAT_SECTORS_PER_FAT_OFFSET u32 <- 0x16 // 2 bytes
FAT_FS_ID_OFFSET u32 <- 0x36 // 8 bytes

// FAT Entry
FAT_ENTRY_ATTRIB_OFFSET u32 <- 0x0b // 1 byte
FAT_ENTRY_CLUSTER_OFFSET u32 <- 0x1a // 2 bytes
FAT_ENTRY_SIZE_OFFSET u32 <- 0x1c // 4 bytes

FAT_ATTRIB_HIDDEN u8 <- 0x02
FAT_ATTRIB_VOLUME_ID u8 <- 0x08
FAT_ATTRIB_LONG_FILE_NAME u8 <- 0x0f
FAT_ATTRIB_DIR u8 <- 0x10

FAT_FILE_FREE u8 <- 0xe5

StorageFsFat fun: storageArea blob<StorageArea> -> blob<StorageFs>
    storageFs blob<StorageFs>

    storageFs.storageArea <- storageArea
    storageFs.rootEntry <- {storageFsFatRootEntry.adr}
    storageFs.subEntriesForEntry <- {storageFsFatSubEntriesForEntry.adr}
    storageFs.entryForPath <- {storageFsFatEntryForPath.adr}
    storageFs.readEntry <- {storageFsFatReadEntry.adr}

    // Init FAT
    pFatBuffer ptr<data<u8>> <- @Mem.allocateBytes(512).vadr.ptr<data<u8>>
    storageArea.readSectors.val({storageArea.adr}, 0, 1, pFatBuffer)

    pInfo ptr<u32>

    // read values
    pInfo <- {pFatBuffer.vadr + FAT_BYTES_PER_SECTOR_OFFSET}
    bytesPerSector u32 <- pInfo.val & 0xffff
    storageFs.fatBytesPerSector <- bytesPerSector

    pInfo <- {pFatBuffer.vadr + FAT_SECTORS_PER_CLUSTER_OFFSET}
    sectorsPerCluster u32 <- pInfo.val & 0xff
    storageFs.fatSectorsPerCluster <- sectorsPerCluster

    pInfo <- {pFatBuffer.vadr + FAT_RESERVED_SECTORS_COUNT_OFFSET}
    reservedSectorsCount u32 <- pInfo.val & 0xff

    pInfo <- {pFatBuffer.vadr + FAT_FATS_COUNT_OFFSET}
    fatsCount u32 <- pInfo.val & 0xff

    pInfo <- {pFatBuffer.vadr + FAT_ROOT_DIR_ENTRIES_COUNT_OFFSET}
    rootDirEntriesCount u32 <- pInfo.val & 0xffff
    storageFs.fatRootDirEntriesCount <- rootDirEntriesCount

    pInfo <- {pFatBuffer.vadr + FAT_SECTORS_PER_FAT_OFFSET}
    sectorsPerFat u32 <- pInfo.val & 0xffff

    // calculated values
    fatFirstSector u32 <- reservedSectorsCount

    storageFs.fatRootDirFirstSector <- fatFirstSector + sectorsPerFat * fatsCount

    storageFs.fatRootDirSectorsCount <- (rootDirEntriesCount * FAT_BYTES_PER_ENTRY) / bytesPerSector

    storageFs.fatFirstDataSector <- storageFs.fatRootDirFirstSector + storageFs.fatRootDirSectorsCount

    // FAT type
    pInfo <- {pFatBuffer.vadr + FAT_FS_ID_OFFSET + 4}
    if pInfo.val & 0xff = '2': storageFs.kind <- FS_KIND_FAT12
    else if pInfo.val & 0xff = '6': storageFs.kind <- FS_KIND_FAT16

    // load fat
    storageFs.pFat <- @Mem.allocateBytes(sectorsPerFat * bytesPerSector).vadr.ptr<data<u8>>
    storageArea.readSectors.val({storageArea.adr}, fatFirstSector, sectorsPerFat, storageFs.pFat)

    ret storageFs
;

storageFsFatRootEntry fun: it ptr<blob<StorageFs>> -> blob<StorageFsEntry>
    rootEntry blob<StorageFsEntry>
    rootEntry.kind <- STORAGE_FS_ENTRY_KIND_DIR
    rootEntry.name <- "/"
    ret rootEntry
;

storageFsFatSubEntriesForEntry fun: it ptr<blob<StorageFs>>, parentEntry blob<StorageFsEntry> -> data<blob<StorageFsEntry>, 32>
    subEntries data<blob<StorageFsEntry>, 32>
    rep i u32 <- 0, i < 32, i <- i + 1
        subEntries[i].kind <- 0
        subEntries[i].name <- "\0"
        subEntries[i].entrySize <- 0
        subEntries[i].fatCluster <- 0
    ;

    pFatDirEntries ptr<data<u8>>
    dirEntriesCount u32
    parentEntryName blob<@B.String> <- @B.String(parentEntry.name)
    if parentEntryName.isEqual.val({parentEntryName.adr}, @B.String("/"))
        dirEntriesCount <- it.val.fatRootDirEntriesCount
        pFatDirEntries <- @Mem.allocateBytes(dirEntriesCount * FAT_BYTES_PER_ENTRY).vadr.ptr<data<u8>>
        it.val.storageArea.readSectors.val({it.val.storageArea.adr}, it.val.fatRootDirFirstSector, it.val.fatRootDirSectorsCount, pFatDirEntries)
    else
        dirEntriesCount <- 32 // TODO: Implement this properly
        pFatDirEntries <- @Mem.allocateBytes(dirEntriesCount * FAT_BYTES_PER_ENTRY).vadr.ptr<data<u8>>
        it.val.readEntry.val(it, parentEntry, pFatDirEntries)
    ;

    entriesCount u32 <- 0
    pFatFileEntry ptr<data<u8>>  <- pFatDirEntries
    rep i u32 <- 0, i < dirEntriesCount and pFatFileEntry.val[0] != 0x00, i <- i + 1
        // first gather basic info about the entry
        attribute u8 <- pFatFileEntry.val[FAT_ENTRY_ATTRIB_OFFSET]
        isLongFileName bool <- attribute & FAT_ATTRIB_LONG_FILE_NAME = FAT_ATTRIB_LONG_FILE_NAME
        isVolumeId bool <- attribute & FAT_ATTRIB_VOLUME_ID = FAT_ATTRIB_VOLUME_ID and not isLongFileName
        isHidden bool <- attribute & FAT_ATTRIB_HIDDEN = FAT_ATTRIB_HIDDEN
        isDirectory bool <- attribute & FAT_ATTRIB_DIR = FAT_ATTRIB_DIR
        isNavigationDirectory bool <- (pFatFileEntry.val[0] = '.' and pFatFileEntry.val[1] = ' ') or (pFatFileEntry.val[0] = '.' and pFatFileEntry.val[1] = '.' and pFatFileEntry.val[2] = ' ') 
        isFile bool <- not isLongFileName and not isVolumeId and not isNavigationDirectory and not isDirectory and pFatFileEntry.val[0] != FAT_FILE_FREE

        name data<u8, 16>
        // copy name
        if isVolumeId or isDirectory or isFile
            targetIndex u32 <- 0
            sourceIndex u32 <- 0
            // file name
            rep sourceIndex < 8, sourceIndex <- sourceIndex + 1
                if pFatFileEntry.val[sourceIndex] != ' '
                    name[targetIndex] <- pFatFileEntry.val[sourceIndex]
                    targetIndex <- targetIndex + 1
                ;
            ;
            // dot
            if not isDirectory and not isVolumeId
                name[targetIndex] <- '.'
                targetIndex <- targetIndex + 1
            ;
            // extension
            rep sourceIndex < 11, sourceIndex <- sourceIndex + 1
                if pFatFileEntry.val[sourceIndex] != ' '
                    name[targetIndex] <- pFatFileEntry.val[sourceIndex]
                    targetIndex <- targetIndex + 1
                ;
            ;
            name[targetIndex] <- 0
        ;

        if isVolumeId
            it.val.name <- name
        else if isDirectory
            // kind
            subEntries[entriesCount].kind <- STORAGE_FS_ENTRY_KIND_DIR
            // name
            subEntries[entriesCount].name <- name
            // size
            pSize ptr<u32> <- {pFatFileEntry.vadr + FAT_ENTRY_SIZE_OFFSET}
            subEntries[entriesCount].entrySize <- pSize.val
            // cluster
            pCluster ptr<u32> <- {pFatFileEntry.vadr + FAT_ENTRY_CLUSTER_OFFSET}
            subEntries[entriesCount].fatCluster <- pCluster.val & 0xffff

            entriesCount <- entriesCount + 1
        else if isFile
            // kind
            subEntries[entriesCount].kind <- STORAGE_FS_ENTRY_KIND_FILE
            //name
            subEntries[entriesCount].name <- name
            // size
            pSize ptr<u32> <- {pFatFileEntry.vadr + FAT_ENTRY_SIZE_OFFSET}
            subEntries[entriesCount].entrySize <- pSize.val
            // cluster
            pCluster ptr<u32> <- {pFatFileEntry.vadr + FAT_ENTRY_CLUSTER_OFFSET}
            subEntries[entriesCount].fatCluster <- pCluster.val & 0xffff

            entriesCount <- entriesCount + 1
        ;

        // go to the next entry
        pFatFileEntry <- {pFatFileEntry.vadr + FAT_BYTES_PER_ENTRY}
    ;

    ret subEntries
;

storageFsFatEntryForPath fun: it ptr<blob<StorageFs>>, path blob<@B.String> -> blob<StorageFsEntry>
    emptyEntry blob<StorageFsEntry>
    currentEntry blob<StorageFsEntry>
    nextEntryName blob<@B.String>
    isNextEntryFound bool

    // path must start with a slash
    if path.string[0] != '/': ret emptyEntry
    currentEntry <- it.val.rootEntry.val(it)
    path <- path.subStringFrom.val({path.adr}, 1)
    isNextEntryFound <- true // asume true cause we start with the root dir

    // go through each path components until the end or if one cannot be found
    rep path.length.val({path.adr}) > 0 and isNextEntryFound
        separatorIndex u32 <- path.find.val({path.adr}, @B.StringForChar('/'))
        // if path components are still remaining, take name until the next slash /
        if separatorIndex > 0
            nextEntryName <- path.subStringTo.val({path.adr}, separatorIndex)
            path <- path.subStringFrom.val({path.adr}, separatorIndex + 1)
        // otherwise take the whole remaining path as the next entry name
        else
            nextEntryName <- path
            path <- @B.String("")
        ;

        // get list of subentries for the current entry
        subEntries data<blob<StorageFsEntry>> <- it.val.subEntriesForEntry.val(it, currentEntry)
        // reset the check for the current directory
        isNextEntryFound <- false
        rep i u32 <- 0, i < subEntries.count and not isNextEntryFound, i <- i + 1
            // for each of the entry check if the path component matches with it
            if nextEntryName.isEqual.val({nextEntryName.adr}, @B.String(subEntries[i].name))
                currentEntry <- subEntries[i]
                isNextEntryFound <- true
            ;
        ;

        // required entry in the path nt found
        if not isNextEntryFound: ret emptyEntry
    ;

    ret currentEntry
;

storageFsFatReadEntry fun: it ptr<blob<StorageFs>>, entry blob<StorageFsEntry>, targetAdr ptr<data<u8>> -> u32
    cluster u32 <- entry.fatCluster
    isFinished bool <- false

    rep not isFinished
        sector u32 <- (cluster - 2) * it.val.fatSectorsPerCluster + it.val.fatFirstDataSector
        it.val.storageArea.readSectors.val({it.val.storageArea.adr}, sector, it.val.fatSectorsPerCluster, targetAdr)
        targetAdr <- {targetAdr.vadr + it.val.fatBytesPerSector * it.val.fatSectorsPerCluster}

        if it.val.kind = FS_KIND_FAT12
            // we multiply by 1.5 because FAT12 uses 1.5 bytes cluster entry
            clusterIndex u32 <- cluster * 3 / 2
            // calculate next cluster depending on wethere cluster index is odd or even
            pCluster ptr<u32> <- {it.val.pFat.vadr + clusterIndex}

            if cluster & 0x01 = 0
                cluster <- pCluster.val & 0x0fff
            else
                cluster <- (pCluster.val & 0xfff0) >> 4
            ;

            isFinished <- cluster >= FAT12_EOF
        else if it.val.kind = FS_KIND_FAT16
            clusterIndex u32 <- cluster * 2
            pCluster ptr<u32> <- {it.val.pFat.vadr + clusterIndex}
            cluster <- pCluster.val & 0xffff // just get 2 bytes

            isFinished <- cluster >= FAT16_EOF
        ;
    ;
    ret 0
;