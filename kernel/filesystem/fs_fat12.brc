@module fs_fat12

@import mem
@import bios_service
@import term

BYTES_PER_SECTOR u32 <- 512
RESERVED_SECTORS_COUNT u32 <- 1
FATS_COUNT u32 <- 2
SECTORS_PER_FAT u32 <- 9
ROOT_DIR_ENTRIES_COUNT u32 <- 512
BYTES_PER_ENTRY u32 <- 32

ATTRIB_HIDDEN u32 <- 0x02
ATTRIB_VOLUME_ID u32 <- 0x08
ATTRIB_LONG_FILE_NAME u32 <- 0x0f
ATTRIB_DIR u32 <- 0x10

FAT_FILE_FREE u32 <- 0xe5

OFFSET_SIZE u32 <- 28
OFFSET_CLUSTER u32 <- 26

FILE_ENTRY_KIND_FILE u32 <- 1
FILE_ENTRY_KIND_DIR u32 <- 2

pFatEntry ptr<data<u8>>

FileEntry blob
    fileName data<u8, 64>
    kind u32
    fileSize u32
    cluster u32
    subDirEntry ptr<blob<FileEntry>>
    nextFileEntry ptr<blob<FileEntry>>
;

rootDirEntry blob<FileEntry>
volumeName data<u8, 64>

@export init fun
    pFatEntry <- @mem.allocateBytes(SECTORS_PER_FAT * BYTES_PER_SECTOR)
    @bios_service.readSectors(
        0,
        RESERVED_SECTORS_COUNT,
        SECTORS_PER_FAT,
        pFatEntry
    )
    initRootDir()

    printDirEntry({ rootDirEntry.adr })
;

initRootDir fun
    rootDirEntry <- { "/", 0, 0, FILE_ENTRY_KIND_DIR, { 0x00 }, { 0x00 } }

    pFatFileEntries ptr<data<u8>> <- @mem.allocateBytes(ROOT_DIR_ENTRIES_COUNT * BYTES_PER_ENTRY)
    @bios_service.readSectors(
        0,
        RESERVED_SECTORS_COUNT + SECTORS_PER_FAT * FATS_COUNT,
        ROOT_DIR_ENTRIES_COUNT * BYTES_PER_ENTRY / BYTES_PER_SECTOR,
        pFatFileEntries
    )

    // Got through each fat file data
    pFatFileEntry ptr<data<u8>> <- pFatFileEntries
    // keeping track of the current file (starting at root dir)
    pCurrentFileEntry ptr<blob<FileEntry>> <- { 0 }
    rep i u32 <- 0, i < ROOT_DIR_ENTRIES_COUNT and pFatFileEntry.val[0] != 0x00.u8, i <- i + 1
        isVolumeId bool <- pFatFileEntry.val[11].u32 & 0x0f = ATTRIB_VOLUME_ID

        // Get name of the volume
        if isVolumeId
            if pFatFileEntry.val[0] = FAT_FILE_FREE.u8
                volumeName <- ""
            else
                // first figure out how long is the volume name (padded with spaces at the end)
                lastIndex u32 <- 10 
                rep lastIndex > 0 and pFatFileEntry.val[lastIndex] = ' '.u8: lastIndex <- lastIndex - 1
                // then copy the name, with 0 at the end
                rep nameIndex u32 <- 0, nameIndex <= lastIndex, nameIndex <- nameIndex + 1
                    volumeName[nameIndex] <- pFatFileEntry.val[nameIndex]
                ;
                volumeName[lastIndex+1] <- 0
            ;
        ;

        pFileEntry ptr<blob<FileEntry>> <- fileEntryForFatFileData(pFatFileEntry)
        if pFileEntry.vAdr != 0
            // is if the first file in the directory?
            if pCurrentFileEntry.vAdr = 0
                rootDirEntry.subDirEntry <- pFileEntry
            else
                pCurrentFileEntry.val.nextFileEntry <- pFileEntry
            ;
            pCurrentFileEntry <- pFileEntry
        ;

        pFatFileEntry <- { pFatFileEntry.vAdr + BYTES_PER_ENTRY }
    ;
;

initDir fun: pDirEntry ptr<blob<FileEntry>>
    //if pDirEntry.val.kind != FILE_ENTRY_KIND_DIR: ret

    pFatFileEntries ptr<data<u8>> <- @mem.allocateBytes(BYTES_PER_SECTOR)

    pCurrentFileEntry ptr<blob<FileEntry>> <- { 0 }
    rep cluster u32 <- pDirEntry.val.cluster, true, cluster < 0x0ff8 and cluster != 0
        sectorIndex u32 <- cluster + RESERVED_SECTORS_COUNT + SECTORS_PER_FAT * FATS_COUNT + (ROOT_DIR_ENTRIES_COUNT * BYTES_PER_ENTRY) / BYTES_PER_SECTOR - 2
        @bios_service.readSectors(
            0,
            sectorIndex,
            1,
            pFatFileEntries
        )

        // get all files from the current cluster
        pFatFileEntry ptr<data<u8>> <- pFatFileEntries
        rep i u32 <- 0, i <  BYTES_PER_SECTOR / BYTES_PER_ENTRY and pFatFileEntry.val[0] != 0x00.u8, i <- i + 1
            pFileEntry ptr<blob<FileEntry>> <- fileEntryForFatFileData(pFatFileEntry)
            if pFileEntry.vAdr != 0
                // is if the first file in the directory?
                if pCurrentFileEntry.vAdr = 0
                    pDirEntry.val.subDirEntry <- pFileEntry
                else
                    pCurrentFileEntry.val.nextFileEntry <- pFileEntry
                ;
                pCurrentFileEntry <- pFileEntry
            ;

            pFatFileEntry <- { pFatFileEntry.vAdr + BYTES_PER_ENTRY }
        ;

        // get next cluster
        // we multiply by 1.5 because FAT12 uses 1.5 bytes cluster entry
        clusterIndex u32 <- cluster * 3 / 2
        // calculate next cluster depending on wethere cluster index is odd or even
        if cluster & 0x01 = 0
            cluster <- pFatEntry.val[clusterIndex].u32 + ((pFatEntry.val[clusterIndex + 1].u32 & 0x0f) << 8)
        else
            cluster <- (pFatEntry.val[clusterIndex].u32 >> 4) + (pFatEntry.val[clusterIndex + 1].u32 << 4)
        ;
    ;
;

fileEntryForFatFileData fun: pFatFileEntry ptr<data<u8>> -> ptr<blob<FileEntry>>
    pFileEntry ptr<blob<FileEntry>> <- { 0x00 }

    attribute u32 <- pFatFileEntry.val[11].u32

    isHidden bool <- attribute & 0x0f = ATTRIB_HIDDEN
    isVolumeId bool <- attribute & 0x0f = ATTRIB_VOLUME_ID
    isLongFileName bool <- attribute & 0x0f = ATTRIB_LONG_FILE_NAME
    isDirectory bool <- attribute & 0xf0 = ATTRIB_DIR
    isNavigationDirectory bool <- (pFatFileEntry.val[0] = '.'.u8 and pFatFileEntry.val[1] = ' '.u8) or (pFatFileEntry.val[0] = '.'.u8 and pFatFileEntry.val[1] = '.'.u8 and pFatFileEntry.val[2] = ' '.u8) 

    if not isLongFileName and not isVolumeId and not isNavigationDirectory and pFatFileEntry.val[0].u32 != FAT_FILE_FREE
        pFileEntry <- @mem.allocateBytes(64 + 4 * 5)
        pFileEntry.val.subDirEntry <- { 0x00 }
        pFileEntry.val.nextFileEntry <- { 0x00 }

        // copy name
        targetIndex u32 <- 0
        sourceIndex u32 <- 0
        // file name
        rep sourceIndex < 8, sourceIndex <- sourceIndex + 1
            if pFatFileEntry.val[sourceIndex] != ' '.u8
                pFileEntry.val.fileName[targetIndex] <- pFatFileEntry.val[sourceIndex]
                targetIndex <- targetIndex + 1
            ;
        ;
        // dot
        if not isDirectory
            pFileEntry.val.fileName[targetIndex] <- '.'.u8
            targetIndex <- targetIndex + 1
        ;
        // extension
        rep sourceIndex < 11, sourceIndex <- sourceIndex + 1
            if pFatFileEntry.val[sourceIndex] != ' '.u8
                pFileEntry.val.fileName[targetIndex] <- pFatFileEntry.val[sourceIndex]
                targetIndex <- targetIndex + 1
            ;
        ;
        pFileEntry.val.fileName[targetIndex] <- 0

        // kind
        pFileEntry.val.kind <- if isDirectory: FILE_ENTRY_KIND_DIR else: FILE_ENTRY_KIND_FILE

        // size
        pFileEntry.val.fileSize <- pFatFileEntry.val[OFFSET_SIZE].u32
        pFileEntry.val.fileSize <- pFileEntry.val.fileSize + (pFatFileEntry.val[OFFSET_SIZE + 1].u32 << 8)
        pFileEntry.val.fileSize <- pFileEntry.val.fileSize + (pFatFileEntry.val[OFFSET_SIZE + 2].u32 << 16)
        pFileEntry.val.fileSize <- pFileEntry.val.fileSize + (pFatFileEntry.val[OFFSET_SIZE + 3].u32 << 24)

        // cluster
        pFileEntry.val.cluster <- pFatFileEntry.val[OFFSET_CLUSTER].u32 + (pFatFileEntry.val[OFFSET_CLUSTER + 1].u32 << 8)
    ;

    ret pFileEntry
;

printDirEntry fun: pDirEntry ptr<blob<FileEntry>>
    @term.printString(pDirEntry.val.fileName, @term.FOREGROUND_GRAY)
    @term.printNewLine()

    rep pCurrentFileEntry ptr<blob<FileEntry>> <- pDirEntry.val.subDirEntry, pCurrentFileEntry.vAdr != 0, pCurrentFileEntry <- pCurrentFileEntry.val.nextFileEntry
        @term.printString(pCurrentFileEntry.val.fileName, @term.FOREGROUND_GRAY)
        @term.printString(", ", @term.FOREGROUND_GRAY)

        if pCurrentFileEntry.val.kind = FILE_ENTRY_KIND_DIR
            @term.printString("dir, ", @term.FOREGROUND_GRAY)
        else
            @term.printString("file, ", @term.FOREGROUND_GRAY)
        ;
    
        @term.printNumber(pCurrentFileEntry.val.fileSize, @term.FOREGROUND_GRAY)
        @term.printString(" bytes, cluster ", @term.FOREGROUND_GRAY)

        @term.printNumber(pCurrentFileEntry.val.cluster, @term.FOREGROUND_GRAY)
        @term.printString("\n", @term.FOREGROUND_GRAY)

        if pCurrentFileEntry.val.kind = FILE_ENTRY_KIND_DIR
            if pCurrentFileEntry.val.subDirEntry.vAdr = 0: initDir(pCurrentFileEntry)
            printDirEntry(pCurrentFileEntry)
        ;
    ;
;